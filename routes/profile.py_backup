"""
Profile Blueprint
=================

Handles user profile routes: view profile, edit profile, upload profile/cover photo, follow/unfollow, privacy settings, and related flows.
Renders templates such as social_profile.html, edit_profile.html, etc.

Notes:
- All business logic is delegated to models or utility functions.
- No business logic in routes; routes only handle request/response and session.
"""

import importlib

# === Standard Library Imports ===
import os
import re
import secrets
import shutil
import time
import traceback
from datetime import datetime

# === Third-Party Imports ===
from flask import (
    Blueprint,
    current_app,
    flash,
    jsonify,
    redirect,
    render_template,
    request,
    session,
    url_for,
)
from werkzeug.utils import secure_filename

# === Project Imports ===
from forms.profile_forms import ProfileEditForm
from models import user as user_module

importlib.reload(user_module)
from models.face import Face
from models.sqlalchemy_models import Notification, db
from models.user import User
from routes.auth import login_required
from utils.db.database import get_users_db_connection
from utils.emergency_fix import fix_user_fields, reset_field_defaults
from utils.face.recognition import rebuild_faiss_index
from utils.image_paths import (
    normalize_extracted_face_path,
    normalize_profile_image_path,
)

# === Blueprint Definition ===
profile = Blueprint("profile", __name__)


# --- Mobile Profile Demo Route ---
@profile.route("/mobile_profile")
def mobile_profile():
    """
    Demo mobile profile endpoint for previewing a user profile on mobile UI.
    """
    user = {
        "name": "Alex Johnson",
        "image_url": "/static/images/example.jpg",  # Update this path to your actual user image
        "hometown": "Seattle, WA",
        "birthday": "April 15, 1990",
        "decade": "1980s",
        "state": "NY",
        "bio": "A creative spirit with a passion for connecting with new faces and exploring the world through different perspectives.",
    }
    return render_template("mobile_profile.html", user=user)


# =============================
# DEV/DEBUG routes and utilities moved to routes/dev.py
# =============================


# =============================
# IMAGE UTILITY FUNCTIONS
# =============================
def allowed_file(filename):
    """
    Check if the file has an allowed extension.
    """
    ALLOWED_EXTENSIONS = {"png", "jpg", "jpeg", "webp"}
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS


def save_image(file, folder, is_profile=False, user_id=None):
    current_app.logger.info(f"[save_image] CALLED with file={getattr(file, 'filename', None)}, folder={folder}, is_profile={is_profile}, user_id={user_id}")
    """
    Save image and return the filename. If is_profile is True, also add to face database.
    Only imports numpy, PIL.Image, and face_recognition if needed.
    """
    import face_recognition # Keep local for now, can be global if other profile routes need it
    from PIL import Image, UnidentifiedImageError

    # Use Pillow's Resampling enum if available (Pillow >= 9.0.0)
    try:
        LANCZOS = Image.Resampling.LANCZOS
        BICUBIC = Image.Resampling.BICUBIC
    except AttributeError:
        LANCZOS = Image.LANCZOS
        BICUBIC = Image.BICUBIC

    import numpy as np # Keep local for now

    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        base_name, extension = os.path.splitext(filename)
        if user_id is None:
            # Fallback, but prefer explicit user_id from caller
            user_id = session.get("user_id", "unknown") 
        new_filename = f"{base_name}_{user_id}_{secrets.token_hex(4)}{extension}" # Added token for more uniqueness
        
        # Ensure the target directory exists
        # The 'folder' path is expected to be relative to app.root_path, e.g., 'static/profile_pics'
        absolute_folder_path = os.path.join(current_app.root_path, folder)
        os.makedirs(absolute_folder_path, exist_ok=True)
        
        save_path = os.path.join(absolute_folder_path, new_filename)
        
        current_app.logger.info(f"[save_image] Attempting to save file to: {save_path}")
        try:
            # Ensure file pointer is at the start before saving
            file.stream.seek(0) 
            file.save(save_path)
            current_app.logger.info(f"[save_image] File initially saved to: {save_path}")

            # Process the saved image (e.g., resize)
            try:
                with Image.open(save_path) as img:
                    # Convert to RGB if it's a palette-based image (e.g., some PNGs) or has alpha, to avoid issues with some operations or formats
                    if img.mode == 'P' or img.mode == 'RGBA':
                        img = img.convert('RGB')
                        current_app.logger.info(f"[save_image] Converted image to RGB: {save_path}")

                    max_size = (800, 800) # Max dimensions for profile images
                    if img.width > max_size[0] or img.height > max_size[1]:
                        img.thumbnail(max_size, LANCZOS)
                        current_app.logger.info(f"[save_image] Image resized: {save_path}")
                    
                    # Save potentially modified image (resized, converted)
                    # For JPG, specify quality; for PNG, optimize
                    if new_filename.lower().endswith(('.jpg', '.jpeg')):
                        img.save(save_path, quality=85, optimize=True)
                    elif new_filename.lower().endswith('.png'):
                        img.save(save_path, optimize=True)
                    else:
                        img.save(save_path) # Default save for other formats like webp, gif
                    current_app.logger.info(f"[save_image] Image processed and re-saved to: {save_path}")

            except UnidentifiedImageError:
                current_app.logger.error(f"[save_image] Cannot identify image file (possibly corrupt or unsupported format): {save_path}")
                if os.path.exists(save_path):
                    os.remove(save_path)
                    current_app.logger.warning(f"[save_image] Removed unidentified image file: {save_path}")
                return None # Critical error with image file itself
            except Exception as e_img_proc:
                current_app.logger.error(f"[save_image] Error processing image with PIL: {e_img_proc}", exc_info=True)
                # Optionally remove the file if processing failed badly, but might be okay if it's just a minor processing issue
                # For now, let's assume the initial save was okay if PIL processing fails, and return the filename.
                # If the image is critical to be processed, then `return None` and remove file.
                # However, if it was saved, it might still be usable by the browser even if PIL had an issue.
                pass # Allow returning filename of the initially saved (but possibly unoptimized/unresized) image

        except Exception as e_save:
            current_app.logger.error(f"[save_image] Error saving file stream: {e_save}", exc_info=True)
            return None # Failed to save the file stream initially

        current_app.logger.info(f"[save_image] Successfully processed. Returning new filename: {new_filename}")
        return new_filename
        
    current_app.logger.warning(f"[save_image] File not saved (file object issue or not an allowed file type): {getattr(file, 'filename', 'No filename')}")
    return None


from utils.face.indexing import index_profile_face # This import is fine here if other fns in profile.py use it.


@profile.route("/api/user", methods=["GET"])
@login_required
def api_user():
    """Return current user's profile info as JSON for frontend use."""
    from flask_login import current_user
    user = current_user
    if not user or not getattr(user, 'is_authenticated', False):
        return jsonify({"success": False, "error": "Not authenticated"}), 401
    # Compose detail string (e.g., city, state)
    detail = ""
    if hasattr(user, "current_location_city") and hasattr(user, "current_location_state"):
        if user.current_location_city and user.current_location_state:
            detail = f"{user.current_location_city}, {user.current_location_state}"
        elif user.current_location_city:
            detail = user.current_location_city
        elif user.current_location_state:
            detail = user.current_location_state
    # Fallback to hometown if no current location
    if not detail and hasattr(user, "hometown") and user.hometown:
        detail = user.hometown
    # Get image URL (use method if available)
    if hasattr(user, "get_profile_image_url"):
        image_url = user.get_profile_image_url()
    else:
        image_url = getattr(user, "profile_image", "/static/images/default_profile.jpg")
    return jsonify({
        "success": True,
        "username": getattr(user, "username", "@user"),
        "image": image_url,
        "detail": detail or ""
    })


@profile.route("/")
@login_required
def view_profile():
    """Show the user's profile."""
    current_app.logger.debug("IN PROFILE ROUTE (view_profile)")
    user_id = session.get("user_id")

    # Get the user
    user = User.get_by_id(user_id)
    if not user:
        flash("User not found", "error")
        return redirect(url_for("main.index"))

    # Get claimed profiles
    claimed_profiles = user.get_claimed_profiles()
    claimed_profile_count = len(claimed_profiles) if claimed_profiles else 0

    # Get user's visible profile matches that were explicitly added by the user
    from models.user_match import UserMatch

    current_app.logger.info(f"Retrieving matches for user {user_id}")
    profile_matches = UserMatch.get_by_user_id(user_id, visible_only=True)
    # Filter out any matches with missing or None IDs (defensive fix)
    profile_matches = [m for m in profile_matches if getattr(m, "id", None)]
    current_app.logger.debug(
        f"Number of matches in view_profile: {len(profile_matches)}"
    )

    # For debugging: log count of matches
    match_count = len(profile_matches) if profile_matches else 0
    current_app.logger.info(f"Found {match_count} matches for user {user_id}")

    # Log all matches found before any processing
    current_app.logger.info(
        f"Found {len(profile_matches) if profile_matches else 0} profile matches in database for user {user_id}"
    )
    if profile_matches:
        match_ids = [match.id for match in profile_matches]
        current_app.logger.info(f"Match IDs: {match_ids}")

    # Pre-fetch match details and ensure similarity scores are set
    if profile_matches:
        for idx, match in enumerate(profile_matches):
            # Get match details and add default similarity if not set
            match_details = match.get_match_details() or {}
            # Log before updating
            current_app.logger.info(
                f"Match {match.id} details before update: {match_details}"
            )

            # If similarity is missing or None, set a default
            if (
                "similarity" not in match_details
                or match_details.get("similarity") is None
            ):
                # Set default similarity directly in the match_details dictionary
                match_details["similarity"] = 75.0
                # Also update the database
                try:
                    match.update(similarity=75.0)
                    current_app.logger.info(
                        f"Updated match {match.id} with default similarity score 75.0"
                    )
                except Exception as e:
                    current_app.logger.error(f"Error updating match {match.id}: {e}")

            # Store the match details directly in the match object for template access
            match.match_details = match_details

            # Robust safe_image_path logic for static directories
            static_dirs = [
                "static/faces",
                "static/profile_pics",
                "static/extracted_faces",
                "static/images",
            ]
            found_path = None
            if match.match_filename:
                for directory in static_dirs:
                    abs_path = os.path.join(
                        current_app.root_path, directory, match.match_filename
                    )
                    if os.path.exists(abs_path):
                        found_path = f"/{directory}/{match.match_filename}"
                        break
            match.safe_image_path = normalize_extracted_face_path(found_path)

            current_app.logger.info(
                f"Match {idx+1}/{len(profile_matches)}: ID={match.id}, filename={match.match_filename}, details={match_details}, safe_image_path={found_path}"
            )
    else:
        current_app.logger.warning(f"No profile matches found for user {user_id}")

    match_count = len(profile_matches) if profile_matches else 0

    # Get counts for stats
    follower_count = user.get_follower_count()
    match_count = len(profile_matches)
    claimed_profile_count = len(claimed_profiles)

    # Get user's posts for the combined view
    from models.social import Post

    user_posts = Post.get_user_posts(user_id, limit=10, offset=0)

    # Pass empty user_activities list for now (will be populated in the future)
    user_activities = []

    # Get current date for age calculation
    current_time = datetime.now().strftime("%Y-%m-%d")

    from forms.profile_forms import ProfileEditForm

    dummy_form = ProfileEditForm()

    # Normalize user profile image path for template
    user_image_url = normalize_profile_image_path(getattr(user, "profile_image", None))

    # Modern template with combined posts and matches
    if "modern" in request.args or request.args.get("view") == "modern":
        return render_template(
            "social_profile_modern.html",
            user=user,
            claimed_profiles=claimed_profiles,
            matches=profile_matches,
            posts=user_posts,
            follower_count=follower_count,
            match_count=match_count,
            claimed_profile_count=claimed_profile_count,
            user_image_url=user_image_url,
            user_activities=user_activities,
            current_time=current_time,
            is_own_profile=True,
            is_current_user=True,
        )
    # Legacy template
    return render_template(
        "social_profile.html",
        user=user,
        claimed_profiles=claimed_profiles,
        profile_matches=profile_matches,
        follower_count=follower_count,
        match_count=match_count,
        claimed_profile_count=claimed_profile_count,
        user_activities=user_activities,
        current_time=current_time,
        is_own_profile=True,
        form=dummy_form,
        user_image_url=user_image_url,
    )


@profile.route("/edit", methods=["GET", "POST"])
@login_required
def edit_profile():
    """
    Edit user profile with enhanced feedback and error handling.
    - GET: Render the edit profile form with current user data.
    - POST: Process form submission, update user fields, handle profile/cover photo uploads.
      - Profile photo is saved, face encoding is extracted and cached if possible.
      - Cover photo is saved.
      - Robust error handling and user feedback for each step.
    """
    user_id = session.get("user_id")
    user = User.get_by_id(user_id)
    form = ProfileEditForm()

    if not user:
        flash("User not found", "error")
        return redirect(url_for("main.index"))

    if request.method == "POST":
        # Debug: log the CSRF token received from the form and in the session cookie
        if hasattr(form, "csrf_token"):
            current_app.logger.info(
                f"[CSRF DEBUG][POST] form.csrf_token.data: {form.csrf_token.data}"
            )
        else:
            current_app.logger.warning(
                "[CSRF DEBUG][POST] form has no csrf_token attribute"
            )
        current_app.logger.info(f"[CSRF DEBUG][POST] session: {dict(session)}")
        # CSRF validation
        if not form.validate_on_submit():
            flash(
                "CSRF token missing or invalid. Please refresh and try again.", "error"
            )
        try:
            # Get form data
            updates = {}

            # Process profile and cover photos
            profile_photo = request.files.get("profile_photo")
            cover_photo = request.files.get("cover_photo")

            # Track which fields are changing
            changed_fields = []

            # Process form data with detailed logging
            current_app.logger.info(f"Processing form data for user {user_id}")

            # Basic information
            form_fields = [
                "username",
                "first_name",
                "last_name",
                "email",
                "birthdate",
                "bio",
                "hometown",
                "website",
                "interests",
            ]

            # Log form data for debugging
            for key, value in request.form.items():
                if "password" not in key:  # Don't log passwords
                    current_app.logger.info(f"Form field {key}: {value}")

            # Collect all updates
            for field in form_fields:
                if field in request.form:
                    new_value = request.form.get(field, "")
                    current_value = getattr(user, field, "")

                    # Special handling for website field - allow it to be empty
                    if field == "website" and not new_value.strip():
                        # If website field is empty or whitespace, store as empty string
                        new_value = ""

                    # Only update if value has changed
                    if new_value != current_value:
                        updates[field] = new_value
                        changed_fields.append(field)
                        current_app.logger.info(
                            f"Field {field} changing from '{current_value}' to '{new_value}'"
                        )

            # Handle Current City explicitly
            new_current_city = request.form.get("current_city", "")
            if hasattr(user, "current_location_city"):
                current_city_val = getattr(user, "current_location_city", "") or "" # Ensure empty string if None
                if new_current_city != current_city_val:
                    updates["current_location_city"] = new_current_city
                    changed_fields.append("current_location_city")
                    current_app.logger.info(
                        f"Field current_location_city changing from '{current_city_val}' to '{new_current_city}'"
                    )
            else:
                current_app.logger.warning(f"User model attribute 'current_location_city' not found for user {user.id}. Cannot update.")

            # Handle Current State explicitly
            new_current_state = request.form.get("current_state", "")
            if hasattr(user, "current_location_state"):
                current_state_val = getattr(user, "current_location_state", "") or "" # Ensure empty string if None
                if new_current_state != current_state_val:
                    updates["current_location_state"] = new_current_state
                    changed_fields.append("current_location_state")
                    current_app.logger.info(
                        f"Field current_location_state changing from '{current_state_val}' to '{new_current_state}'"
                    )
            else:
                current_app.logger.warning(f"User model attribute 'current_location_state' not found for user {user.id}. Cannot update.")

            # Save profile photo if uploaded
            if profile_photo and profile_photo.filename:
                current_app.logger.info(
                    f"[UPLOAD DEBUG] Received profile_photo: {profile_photo.filename}"
                )
                folder = "static/profile_pics"  # Just use a simple folder path
                try:
                    profile_filename = save_image(
                        profile_photo, folder, is_profile=True
                    )
                    if profile_filename:
                        # Store just the filename in the database
                        updates["profile_image"] = profile_filename
                        changed_fields.append("profile_image")
                        current_app.logger.info(
                            f"Successfully saved profile photo: {profile_filename}"
                        )

                        # Index the new profile face (creates DB entries, FAISS update, sets claimed_by_user_id)
                        try:
                            current_app.logger.info(f"Attempting to index profile face: {profile_filename} for user_id: {user.id}")
                            indexed_face_filename = index_profile_face(
                                filename=profile_filename, 
                                user_id=user.id, 
                                username=user.username
                            )
                            if indexed_face_filename:
                                current_app.logger.info(
                                    f"Successfully indexed profile face. Cropped face filename: {indexed_face_filename} for user_id: {user.id}"
                                )
                                # Optionally, you could update user.face_filename here if it's meant to store the *cropped* face filename
                                # For now, user.profile_image stores the original, and Face DB stores the cropped one.
                            else:
                                current_app.logger.warning(
                                    f"Profile face indexing returned None for {profile_filename}, user_id: {user.id}. Face may not be searchable or claimable as expected."
                                )
                                # Do not flash here as safe_extract_face_encoding below might also flash.
                        except Exception as e_index:
                            current_app.logger.error(
                                f"Error during index_profile_face for {profile_filename}, user_id: {user.id}: {e_index}"
                            )
                            flash(
                                "Profile photo saved, but there was an issue making it fully searchable. Please contact support if issues persist.",
                                "warning",
                            )

                        # Extract and cache encoding immediately so search will work
                        # This logic ensures that the user's face encoding is available for search right after upload
                        try:
                            from utils.face.encoding import safe_extract_face_encoding

                            profile_image_path = os.path.join(
                                current_app.root_path, folder, profile_filename
                            )
                            if os.path.exists(profile_image_path):
                                encoding = safe_extract_face_encoding(
                                    profile_image_path, current_app
                                )
                                cache_key = f"face_encoding_{profile_image_path}"
                                cache = current_app.extensions.get("cache_instance")
                                if cache:
                                    cache.set(cache_key, encoding, timeout=3600)
                                current_app.logger.info(
                                    f"Extracted and cached encoding for profile image: {profile_image_path}"
                                )
                                if encoding is None:
                                    flash(
                                        "Profile photo saved, but face could not be detected for search.",
                                        "warning",
                                    )
                                    current_app.logger.warning(
                                        f"Face not detected in uploaded profile image: {profile_image_path}"
                                    )
                        except Exception as e:
                            current_app.logger.error(
                                f"Error extracting face encoding: {e}"
                            )
                            flash(
                                "Profile photo saved, but face could not be processed for search.",
                                "warning",
                            )
                    else:
                        # Only clear or change the field if upload succeeded
                        current_app.logger.error(
                            "Profile photo upload failed: profile_filename is None"
                        )
                        flash(
                            "Error saving profile photo. Please try again with a different image.",
                            "error",
                        )
                        return redirect(url_for("profile.edit_profile"))
                except Exception as e:
                    current_app.logger.error(f"Error saving profile photo: {e}")
                    flash(
                        "Error saving profile photo. Please try again with a different image.",
                        "error",
                    )
                    return redirect(url_for("profile.edit_profile"))

            # Save cover photo if uploaded
            if cover_photo and cover_photo.filename:
                current_app.logger.info(
                    f"[UPLOAD DEBUG] Received cover_photo: {cover_photo.filename}"
                )
                folder = current_app.config.get('COVER_PHOTOS_FOLDER', 'static/cover_photos') # Corrected path
                try:
                    cover_filename = save_image(cover_photo, folder, is_profile=False)
                    if cover_filename:
                        # Store just the filename in the database
                        updates["cover_photo"] = cover_filename
                        changed_fields.append("cover_photo")
                        current_app.logger.info(
                            f"Successfully saved cover photo: {cover_filename}"
                        )
                    else:
                        current_app.logger.error(
                            "Cover filename is None after save_image"
                        )
                        flash(
                            "Error saving cover photo. Please try again with a different image.",
                            "error",
                        )
                        return redirect(url_for("profile.edit_profile"))
                except Exception as e:
                    current_app.logger.error(f"Error saving cover photo: {e}")
                    flash(
                        "Error saving cover photo. Please try again with a different image.",
                        "error",
                    )
                    return redirect(url_for("profile.edit_profile"))

            # Check for problematic fields and handle them separately
            # Some fields may require direct DB updates due to legacy constraints or custom logic
            problematic_fields = [
                "first_name",
                "last_name",
                "birthdate",
                "hometown",
                "current_location_city",
                "current_location_state",
            ]
            direct_updates = {}
            standard_updates = {}

            for field, value in updates.items():
                if field in problematic_fields:
                    direct_updates[field] = value
                else:
                    standard_updates[field] = value

            # Apply standard updates if any
            update_success = True
            if standard_updates:
                current_app.logger.info(
                    f"Applying standard updates: {standard_updates}"
                )
                update_success = user.update(**standard_updates)
                if not update_success:
                    current_app.logger.error(
                        "Standard profile update failed - database error"
                    )
                    return redirect(
                        url_for(
                            "profile.edit_profile",
                            status="error",
                            message="Profile update failed due to a database error",
                        )
                    )

            # Apply emergency fix for problematic fields if any
            emergency_update_success = True
            if direct_updates:
                current_app.logger.info(
                    f"Applying EMERGENCY fix for problematic fields: {direct_updates}"
                )
                # Apply the emergency fix
                emergency_update_success = fix_user_fields(user_id, direct_updates)
                if not emergency_update_success:
                    current_app.logger.error(
                        "Emergency fix failed for problematic fields"
                    )
                    return redirect(
                        url_for(
                            "profile.edit_profile",
                            status="error",
                            message="Critical error updating profile fields. Please contact support.",
                        )
                    )

            # Verify all changes were applied
            updated_user = User.get_by_id(user_id)
            verification_success = True
            failed_fields = []

            # Check all changed fields
            for field in changed_fields:
                expected_value = updates.get(field)
                actual_value = getattr(updated_user, field, None)

                current_app.logger.info(
                    f"Verifying field '{field}': expected='{expected_value}', actual='{actual_value}'"
                )

                if expected_value != actual_value:
                    verification_success = False
                    failed_fields.append(field)
                    current_app.logger.error(
                        f"Field verification failed for {field}: expected '{expected_value}', got '{actual_value}'"
                    )

            # Build redirect based on verification
            # After attempting to update the user, verify all changed fields to ensure DB consistency
            if not verification_success:
                return redirect(
                    url_for(
                        "profile.edit_profile",
                        status="warning",
                        message=f'Some fields could not be updated: {", ".join(failed_fields)}',
                    )
                )
            elif changed_fields:  # If any fields were actually changed
                return redirect(
                    url_for(
                        "profile.view_profile",
                        status="success",
                        message="Profile updated successfully",
                        changed=",".join(changed_fields),
                    )
                )
            else:
                # No changes were made
                return redirect(
                    url_for(
                        "profile.view_profile",
                        status="info",
                        message="No changes were made to your profile",
                    )
                )
        except Exception as e:
            current_app.logger.error(f"Error updating profile: {e}")
            import traceback

            current_app.logger.error(traceback.format_exc())
            return redirect(
                url_for(
                    "profile.edit_profile",
                    status="error",
                    message="An error occurred while updating your profile",
                )
            )

        # End of POST handler

    # GET request - render the form
    # Get status and message from URL params if present (from redirects)
    status = request.args.get("status")
    message = request.args.get("message")
    if status and message:
        flash(message, status)

    # Normalize user profile image path for template
    user_image_url = normalize_profile_image_path(getattr(user, "profile_image", None))

    return render_template(
        "edit_profile.html", user=user, form=form, user_image_url=user_image_url
    )


@profile.route("/create_default_image", methods=["POST"])
def create_default_image():
    """
    Create a default profile image if it doesn't exist.
    - If a file is uploaded, use it as the default image.
    - Otherwise, generate a simple default image with a blue background and a question mark.
    Returns JSON with success status and message.
    """
    try:
        # Check if the default image already exists
        # This logic ensures the app always has a fallback profile image
        default_image_path = os.path.join(
            current_app.root_path, "static", "default_profile.png"
        )

        if os.path.exists(default_image_path):
            return jsonify({"success": True, "message": "Default image already exists"})

        # If a file was uploaded, use that
        if "default_image" in request.files:
            file = request.files["default_image"]
            file.save(default_image_path)
            return jsonify(
                {"success": True, "message": "Default image created from uploaded file"}
            )

        # Otherwise, create a simple default image
        from PIL import Image, ImageDraw, ImageFont

        # Create a blank image with blue background
        img = Image.new("RGB", (200, 200), color=(78, 115, 223))
        d = ImageDraw.Draw(img)

        # Try to add a question mark
        try:
            font = ImageFont.truetype("arial.ttf", 80)
        except IOError:
            font = ImageFont.load_default()

        # Draw a question mark in the center
        d.text((100, 100), "?", fill="white", font=font, anchor="mm")

        # Save the image
        img.save(default_image_path)

        return jsonify({"success": True, "message": "Default image created"})
    except Exception as e:
        current_app.logger.error(f"Error creating default image: {e}")
        return jsonify({"success": False, "message": str(e)})


@profile.route("/<string:username>") # Added route decorator
@login_required
def view_user_profile(username):
    """
    View another user's profile.
    - Enforces privacy settings (private, friends-only, public) and redirects with feedback as needed.
    - Fetches and displays user's claimed profiles and visible matches, with robust image path logic for matches.
    - Uses flexible directory checking for match images and logs all key actions.
    """
    current_app.logger.debug("IN PROFILE ROUTE (view_user_profile)")
    # Get the user
    user = User.get_by_username(username)

    current_app.logger.info(f"Attempting to view profile for URL username: '{username}'") # DEBUG
    current_app.logger.info(f"User object retrieved: ID={getattr(user, 'id', 'N/A')}, Username={getattr(user, 'username', 'N/A')}, ProfileImage={getattr(user, 'profile_image', 'N/A')}") # DEBUG

    if not user:
        flash("User not found", "error")
        return redirect(url_for("main.index"))

    # Check if this is the current user's profile
    current_user_id = session.get("user_id")
    is_own_profile = current_user_id and current_user_id == user.id

    # Get claimed profiles
    claimed_profiles = user.get_claimed_profiles()

    # Get user's visible profile matches
    from models.user_match import UserMatch

    current_app.logger.info(f"Retrieving matches for user {user.id}")
    profile_matches = UserMatch.get_by_user_id(user.id, visible_only=True)
    current_app.logger.info(
        f"Number of matches in view_user_profile: {len(profile_matches)}"
    )

    # Log matches found for debugging
    match_count = len(profile_matches) if profile_matches else 0
    current_app.logger.info(f"Found {match_count} matches for user {user.id}")

    # Pre-fetch match details and ensure all have similarity scores
    if profile_matches:
        current_app.logger.info(f"Found {len(profile_matches)} matches to process for user {user.id}")
        
        for idx, match in enumerate(profile_matches, 1):
            current_app.logger.info(f"\n=== Processing match {idx}/{len(profile_matches)} ===")
            current_app.logger.info(f"Match ID: {getattr(match, 'id', 'N/A')}")
            current_app.logger.info(f"Match object type: {type(match)}")
            current_app.logger.info(f"Match attributes: {dir(match)}")
            current_app.logger.info(f"Original match_filename: {getattr(match, 'match_filename', 'Not set')}")
            
            # Ensure similarity is set for this match
            if not hasattr(match, "similarity") or match.similarity is None:
                current_app.logger.info("Setting default similarity score of 75.0")
                match.similarity = 75.0

            # Set the filename for the match card image
            if hasattr(match, 'match_filename') and match.match_filename:
                current_app.logger.info(f"Processing match with filename: {match.match_filename}")
                
                # Normalize filename to avoid duplicate directory segments
                filename = match.match_filename or ''
                if filename.startswith('extracted_faces/') or filename.startswith('faces/'):
                    possible_paths = [filename]
                else:
                    possible_paths = [
                        os.path.join('extracted_faces', filename),
                        os.path.join('faces', filename),
                        filename
                    ]
                
                # Check each possible path
                img_found = False
                for img_path in possible_paths:
                    full_path = os.path.join(current_app.static_folder, img_path)
                    current_app.logger.info(f"Checking if exists: {full_path}")
                    if os.path.exists(full_path):
                        current_app.logger.info(f"Found image at: {img_path}")
                        match.filename = img_path
                        img_found = True
                        break
                
                if not img_found:
                    current_app.logger.warning(f"No image found for {match.match_filename} in any location")
                    match.filename = 'default_face.png'
            else:
                current_app.logger.warning("No match_filename attribute found, using default image")
                match.filename = 'default_face.png'
            
            # Set the image URL for the template
            match.image_url = url_for('static', filename=match.filename)
            
            # Log final values
            current_app.logger.info(f"Final filename: {getattr(match, 'filename', 'Not set')}")
            current_app.logger.info(f"Final image_url: {getattr(match, 'image_url', 'Not set')}")
            
            # Ensure other required attributes exist with defaults
            if not hasattr(match, 'privacy_level') or not match.privacy_level:
                match.privacy_level = 'public'
                
            if not hasattr(match, 'is_visible'):
                match.is_visible = True
                
            current_app.logger.info(f"Final match object: {match.__dict__ if hasattr(match, '__dict__') else match}")
            current_app.logger.info(f"Match {idx} processing complete\n")

    # Privacy enforcement: block access to private or friends-only profiles if not allowed
    if user.profile_visibility == "private" and not is_own_profile:
        flash("This profile is private", "warning")
        return redirect(url_for("main.index"))

    # Block access if profile is friends-only and current user is not a friend
    current_user_id = session.get("user_id")
    if (
        user.profile_visibility == "friends"
        and not is_own_profile
        and current_user_id
        and not user.is_following(current_user_id)
    ):
        flash("This profile is only visible to friends", "warning")
        return redirect(url_for("main.index"))

    # Include private info if viewing own profile
    include_private = is_own_profile

    # Get user's posts for the combined view
    from models.social import Post

    user_posts = Post.get_user_posts(user.id, limit=10, offset=0)

    # Get follower count for stats
    follower_count = user.get_follower_count()
    match_count = len(profile_matches) if profile_matches else 0
    claimed_profile_count = len(claimed_profiles) if claimed_profiles else 0

    # Check if current user is following this user
    is_following = False
    if current_user_id and current_user_id != user.id:
        is_following = User.get_by_id(current_user_id).is_following(user.id)

    # Normalize user profile image path for template
    current_app.logger.info(f"VIEWING PROFILE FOR USER: {user.id}, USERNAME: {user.username}") # DEBUG
    current_app.logger.info(f"USER PROFILE IMAGE ATTRIBUTE (user.profile_image): {getattr(user, 'profile_image', 'Attribute not found')}") # DEBUG

    user_image_url = normalize_profile_image_path(getattr(user, "profile_image", None))
    current_app.logger.info(f"NORMALIZED user_image_url for {user.username}: {user_image_url}") # DEBUG

    current_app.logger.info(f"RENDERING social_profile.html WITH USER: ID={getattr(user, 'id', 'N/A')}, Username={getattr(user, 'username', 'N/A')}") # DEBUG

    # Use social_profile_modern.html if requested (modern desktop/mobile layout)
    if "modern" in request.args or request.args.get("view") == "modern":
        return render_template(
            "social_profile_modern.html",
            user=user,
            claimed_profiles=claimed_profiles,
            matches=profile_matches,
            posts=user_posts,
            follower_count=follower_count,
            match_count=match_count,
            claimed_profile_count=claimed_profile_count,
            is_own_profile=is_own_profile,
            is_current_user=is_own_profile,
            include_private=include_private,
            is_following=is_following,
            user_image_url=user_image_url,
        )

    # Otherwise, default to legacy template (original layout)
    from forms.profile_forms import ProfileEditForm

    dummy_form = ProfileEditForm()
    return render_template(
        "social_profile.html",
        user=user,
        claimed_profiles=claimed_profiles,
        profile_matches=profile_matches,
        is_own_profile=is_own_profile,
        is_current_user=is_own_profile,
        include_private=include_private,
        follower_count=follower_count,
        match_count=match_count,
        claimed_profile_count=claimed_profile_count,
        is_following=is_following,
        user_image_url=user_image_url,
        form=dummy_form,
    )


@profile.route("/follow/<int:user_id>", methods=["POST"])
@login_required
def follow_user(user_id):
    """
    Follow a user and create a notification for the followed user.
    - Checks if already following; if not, adds the follower relationship.
    - Creates a notification using SQLAlchemy ORM.
    - Returns JSON response for frontend handling.
    Robust error handling and DB connection management.
    """
    try:
        # Get current user
        current_user_id = session.get("user_id")
        if not current_user_id:
            return jsonify({"error": "Not logged in"}), 401

        # Check if already following
        conn = get_users_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "SELECT * FROM followers WHERE follower_id = ? AND following_id = ?",
            (current_user_id, user_id),
        )
        if cursor.fetchone():
            return jsonify({"error": "Already following this user"}), 400

        # Add follower relationship
        cursor.execute(
            "INSERT INTO followers (follower_id, following_id) VALUES (?, ?)",
            (current_user_id, user_id),
        )

        # Create notification for the followed user
        notification = Notification(
            user_id=user_id,
            type="follow",
            from_user_id=current_user_id,
            created_at=datetime.utcnow(),
        )
        db.session.add(notification)
        db.session.commit()

        conn.commit()
        return jsonify({"message": "Successfully followed user"}), 200

    except Exception as e:
        current_app.logger.error(f"Error following user: {str(e)}")
        return jsonify({"error": "An error occurred"}), 500
    finally:
        if "conn" in locals():
            conn.close()


@profile.route("/unfollow/<int:user_id>", methods=["POST"])
@login_required
def unfollow_user(user_id):
    """
    Unfollow a user.
    - Removes the follower relationship from the followers table.
    - Returns JSON response for frontend handling.
    Robust error handling and DB connection management.
    """
    try:
        current_user_id = session.get("user_id")
        if not current_user_id:
            return jsonify({"error": "Not logged in"}), 401

        conn = get_users_db_connection()
        cursor = conn.cursor()

        # Remove follower relationship
        cursor.execute(
            "DELETE FROM followers WHERE follower_id = ? AND following_id = ?",
            (current_user_id, user_id),
        )

        if cursor.rowcount == 0:
            return jsonify({"error": "Not following this user"}), 400

        conn.commit()
        return jsonify({"message": "Successfully unfollowed user"}), 200

    except Exception as e:
        current_app.logger.error(f"Error unfollowing user: {str(e)}")
        return jsonify({"error": "An error occurred"}), 500
    finally:
        if "conn" in locals():
            conn.close()


@profile.route("/settings")
@login_required
def settings():
    """Redirect to edit profile page (for UI consistency)."""
    return redirect(url_for("profile.edit_profile"))


@profile.route("/matches/privacy", methods=["POST"])
@login_required
def update_match_privacy():
    """
    Update privacy settings for a match.
    - Only allows the owner of the match to update privacy.
    - Returns JSON response for AJAX/frontend handling.
    """
    user_id = session.get("user_id")
    match_id = request.form.get("match_id")
    privacy_level = request.form.get("privacy_level")

    if (
        not match_id
        or not privacy_level
        or privacy_level not in ("public", "friends", "private")
    ):
        return jsonify({"success": False, "message": "Invalid request parameters"})

    # Get the match
    from models.user_match import UserMatch

    match = UserMatch.get_by_id(match_id)

    # Verify ownership
    if not match or str(match.user_id) != str(user_id):
        return jsonify(
            {"success": False, "message": "Match not found or access denied"}
        )

    # Update privacy
    if match.set_privacy(privacy_level):
        return jsonify(
            {
                "success": True,
                "message": f"Privacy updated to {privacy_level}",
                "privacy_level": privacy_level,
            }
        )
    else:
        return jsonify({"success": False, "message": "Failed to update privacy level"})


@profile.route("/like_match/<int:match_id>", methods=["POST"])
@login_required
def like_match(match_id):
    """
    Toggle like for a match and return updated like state and count.
    - Allows a user to like/unlike a match (face) and returns the new state and like count.
    - Returns JSON response for AJAX/frontend use.
    """
    from models.user_match import UserMatch

    user_id = session.get("user_id")
    if not user_id:
        return jsonify({"success": False, "error": "Not logged in"}), 401
    match = UserMatch.get_by_match_id(match_id)
    if not match or not match.face_id:
        return jsonify({"success": False, "error": "Invalid match ID"}), 400
    # Toggle like
    liked = UserMatch.toggle_like(user_id, match.face_id)
    like_count = UserMatch.count_likes(match.face_id)

    # Notify match owner if not liking own match
    if match.user_id != user_id:
        from models.notification import Notification
        Notification.create(
            user_id=match.user_id,
            type=Notification.TYPE_LIKE if hasattr(Notification, 'TYPE_LIKE') else 'like',
            content="Your match card was liked!",
            entity_id=match.id,
            entity_type="match",
            sender_id=user_id
        )
    return jsonify({"success": True, "liked": liked, "like_count": like_count})


@profile.route("/matches/bulk-privacy", methods=["POST"])
@login_required
def update_bulk_match_privacy():
    """Update privacy settings for multiple matches."""
    user_id = session.get("user_id")
    privacy_level = request.form.get("privacy_level")
    match_ids = request.form.getlist("match_ids[]")

    if (
        not match_ids
        or not privacy_level
        or privacy_level not in ("public", "friends", "private")
    ):
        return jsonify({"success": False, "message": "Invalid request parameters"})

    from models.user_match import UserMatch

    success_count = 0
    failed_count = 0

    for match_id in match_ids:
        # Get the match
        match = UserMatch.get_by_id(match_id)

        # Verify ownership
        if not match or str(match.user_id) != str(user_id):
            failed_count += 1
            continue

        # Update privacy
        if match.set_privacy(privacy_level):
            success_count += 1
        else:
            failed_count += 1

    return jsonify(
        {
            "success": True,
            "message": f"Updated {success_count} matches to {privacy_level} privacy. {failed_count} failed.",
            "privacy_level": privacy_level,
            "success_count": success_count,
            "failed_count": failed_count,
        }
    )
